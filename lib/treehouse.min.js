// lib/ui/outline/mod.tsx
var OutlineNode = {
  view({ attrs, state, children }) {
    const node = attrs.data;
    const expanded = node.getAttr("expanded") !== "" ? JSON.parse(node.getAttr("expanded")) : false;
    const hover = (e) => {
      state.hover = true;
      e.stopPropagation();
    };
    const unhover = (e) => {
      state.hover = false;
      e.stopPropagation();
    };
    const toggle = (e) => {
      if (expanded) {
        env.commands.executeCommand("collapse", env.workspace.getContext({ node }));
      } else {
        env.commands.executeCommand("expand", env.workspace.getContext({ node }));
      }
      e.stopPropagation();
    };
    const startEdit = (e) => {
      env.workspace.context.node = node;
      state.editing = true;
      state.buffer = node.getName();
    };
    const finishEdit = (e) => {
      state.editing = false;
      if (!node.isDestroyed) {
        node.setName(state.buffer);
      }
      state.buffer = void 0;
      env.workspace.context.node = null;
    };
    const edit = (e) => {
      state.buffer = e.target.value;
    };
    const startNew = (e) => {
      env.commands.executeCommand("insert-child", env.workspace.getContext({ node }), e.target.value);
      e.stopPropagation();
    };
    const showMenu = (e) => {
      const trigger = e.target.closest("*[data-menu]");
      const rect = trigger.getBoundingClientRect();
      const x = document.body.scrollLeft + rect.x;
      const y = document.body.scrollTop + rect.y + rect.height;
      env.workspace.showMenu(trigger.dataset["menu"], x, y, env.workspace.getContext({ node }));
      e.preventDefault();
    };
    const checkCommands = (e) => {
      switch (e.key) {
        case "Backspace":
          if (e.target.value === "") {
            env.commands.executeCommand("delete", env.workspace.getContext({ node }));
            e.stopPropagation();
            return;
          }
          if (e.target.value !== "" && e.target.selectionStart === 0) {
            console.log("TODO!");
            e.stopPropagation();
            return;
          }
          break;
        case "Enter":
          if (e.target.selectionStart === e.target.value.length) {
            env.commands.executeCommand("insert", env.workspace.getContext({ node }));
            e.stopPropagation();
            return;
          }
          if (e.target.selectionStart === 0) {
            env.commands.executeCommand("insert-before", env.workspace.getContext({ node }));
            e.stopPropagation();
            return;
          }
          if (e.target.selectionStart > 0 && e.target.selectionStart < e.target.value.length) {
            state.buffer = e.target.value.slice(0, e.target.selectionStart);
            env.commands.executeCommand("insert", env.workspace.getContext({ node }), e.target.value.slice(e.target.selectionStart));
            e.stopPropagation();
            return;
          }
          break;
      }
    };
    return /* @__PURE__ */ m("div", { class: "", style: { paddingLeft: "1rem" }, onmouseover: hover, onmouseout: unhover }, /* @__PURE__ */ m("div", { style: {
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      marginTop: "0.125rem",
      marginBottom: "0.125rem"
    } }, /* @__PURE__ */ m(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        style: {
          flexShrink: "0",
          width: "1rem",
          height: "1rem",
          position: "absolute",
          marginLeft: "-1rem",
          userSelect: "none",
          display: state.hover ? "block" : "none"
        },
        onclick: toggle,
        fill: "gray",
        viewBox: "0 0 16 16"
      },
      /* @__PURE__ */ m("circle", { cx: "8", cy: "7", r: "7", fill: "lightgray" }),
      !expanded && /* @__PURE__ */ m("path", { style: { transform: "scale(0.6) translate(5px, 3px)" }, d: "m12.14 8.753-5.482 4.796c-.646.566-1.658.106-1.658-.753V3.204a1 1 0 0 1 1.659-.753l5.48 4.796a1 1 0 0 1 0 1.506z" }),
      expanded && /* @__PURE__ */ m("path", { style: { transform: "scale(0.6) translate(5px, 4px)" }, d: "M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z" })
    ), /* @__PURE__ */ m("svg", { oncontextmenu: showMenu, "data-menu": "node", style: { flexShrink: "0", width: "1rem", height: "1rem", marginRight: "0.5rem", paddingLeft: "1px" }, xmlns: "http://www.w3.org/2000/svg", fill: "gray", viewBox: "0 0 16 16" }, node.getChildren().length > 0 ? /* @__PURE__ */ m("circle", { cx: "8", cy: "7", r: "7", fill: "lightgray" }) : null, /* @__PURE__ */ m("circle", { cx: "8", cy: "7", r: "3" })), /* @__PURE__ */ m("div", { style: { flexGrow: "1", display: "flex" } }, /* @__PURE__ */ m(
      "input",
      {
        id: `input-${node.ID}`,
        type: "text",
        value: state.editing ? state.buffer : node.getName(),
        onfocus: startEdit,
        onblur: finishEdit,
        oninput: edit,
        onkeydown: checkCommands,
        style: {
          border: "0px",
          flexGrow: "1",
          outline: "0px"
        }
      }
    ))), /* @__PURE__ */ m("div", { style: {
      display: expanded ? "flex" : "none",
      flexDirection: "row",
      paddingBottom: "0.25rem"
    } }, /* @__PURE__ */ m("div", { style: { width: "1rem", marginRight: "0.25rem", display: "flex" }, onclick: toggle }, /* @__PURE__ */ m("div", { style: { borderLeft: "1px solid gray", height: "100%", marginLeft: "0.5rem" } })), /* @__PURE__ */ m("div", { style: { flexGrow: "1" } }, node.getChildren().length > 0 ? node.getChildren().map((n) => /* @__PURE__ */ m(OutlineNode, { key: n.ID, data: n })) : /* @__PURE__ */ m("div", { style: {
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      paddingLeft: "1rem",
      marginTop: "0.125rem",
      marginBottom: "0.125rem"
    } }, /* @__PURE__ */ m("svg", { style: { flexShrink: "0", width: "1rem", height: "1rem", marginRight: "0.5rem", paddingLeft: "1px" }, xmlns: "http://www.w3.org/2000/svg", fill: "gray", viewBox: "0 0 16 16" }, /* @__PURE__ */ m("circle", { cx: "8", cy: "7", r: "7", fill: "lightgray" }), /* @__PURE__ */ m("path", { fill: "#555", style: { transform: "translate(0px, -1px)" }, d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" })), /* @__PURE__ */ m("div", { style: { flexGrow: "1", display: "flex" } }, /* @__PURE__ */ m(
      "input",
      {
        type: "text",
        oninput: startNew,
        style: {
          border: "0px",
          flexGrow: "1",
          outline: "0px"
        }
      }
    ))))));
  }
};

// lib/backend/mod.ts
var LocalStorageStore = class {
  loadAll() {
    let item = localStorage.getItem(`treehouse-nodes`);
    if (item === "undefined") {
      item = void 0;
    }
    return JSON.parse(item || "[]");
  }
  saveAll(nodes) {
    localStorage.setItem(`treehouse-nodes`, JSON.stringify(nodes));
  }
  save(n) {
  }
};

// lib/command/keybindings/mod.ts
var KeyBindings = class {
  constructor() {
    this.bindings = [];
  }
  registerBinding(binding) {
    this.bindings.push(binding);
  }
  getBinding(commandId) {
    for (const b of this.bindings) {
      if (b.command === commandId) {
        return b;
      }
    }
    return null;
  }
  evaluateEvent(event) {
    bindings:
      for (const b of this.bindings) {
        let modifiers = b.key.toLowerCase().split("+");
        let key = modifiers.pop();
        if (key !== event.key.toLowerCase()) {
          continue;
        }
        for (const mod of ["shift", "ctrl", "meta", "alt"]) {
          const modState = event[`${mod}Key`];
          if (!modState && modifiers.includes(mod)) {
            continue bindings;
          }
          if (modState && !modifiers.includes(mod)) {
            continue bindings;
          }
        }
        return b;
      }
    return null;
  }
};

// lib/command/mod.ts
var CommandRegistry = class {
  constructor() {
    this.commands = {};
  }
  registerCommand(cmd) {
    this.commands[cmd.id] = cmd;
  }
  executeCommand(id, ...rest) {
    return this.commands[id].action(...rest);
  }
};

// lib/manifold/mod.ts
var Node = class {
  constructor(module, id) {
    this.module = module;
    this.ID = id;
  }
  changed() {
    this.module.changed(this);
  }
  get isDestroyed() {
    return !this.module.nodes.hasOwnProperty(this.ID);
  }
  get raw() {
    return this.module.nodes[this.ID];
  }
  getName() {
    return this.raw.Name;
  }
  setName(val) {
    this.raw.Name = val;
    this.changed();
  }
  getValue() {
    return this.raw.Value;
  }
  getParent() {
    if (!this.raw.Parent)
      return null;
    return new Node(this.module, this.raw.Parent);
  }
  setParent(n) {
    const p = this.getParent();
    if (p !== null) {
      p.raw.Linked.Children.splice(this.getSiblingIndex(), 1);
    }
    this.raw.Parent = n.ID;
    n.raw.Linked.Children.push(this.ID);
    this.changed();
  }
  getChildren() {
    if (!this.raw.Linked.Children)
      return [];
    return this.raw.Linked.Children.map((id) => new Node(this.module, id));
  }
  getAttr(name) {
    return this.raw.Attrs[name] || "";
  }
  setAttr(name, value) {
    this.raw.Attrs[name] = value;
    this.changed();
  }
  getSiblingIndex() {
    const p = this.getParent();
    if (p === null)
      return 0;
    return p.raw.Linked.Children.findIndex((id) => id === this.ID);
  }
  setSiblingIndex(i) {
    const p = this.getParent();
    if (p === null)
      return;
    p.raw.Linked.Children.splice(this.getSiblingIndex(), 1);
    p.raw.Linked.Children.splice(i, 0, this.ID);
    p.changed();
  }
  getPrevSibling() {
    const p = this.getParent();
    if (p === null)
      return null;
    if (this.getSiblingIndex() === 0)
      return null;
    return p.getChildren()[this.getSiblingIndex() - 1];
  }
  getNextSibling() {
    const p = this.getParent();
    if (p === null)
      return null;
    if (this.getSiblingIndex() === p.getChildren().length - 1)
      return null;
    return p.getChildren()[this.getSiblingIndex() + 1];
  }
  destroy() {
    this.module.destroy(this);
  }
  // getAncestors
  // getPath
  // addComponent
  // getComponent
  // getComponents
  // getComponentsInChildren
  // getComponentsInParents
  // walk
  // duplicate?
};
var Module = class {
  constructor() {
    this.nodes = { "@root": {
      ID: "@root",
      Name: "@root",
      Linked: { Children: [], Components: [] },
      Attrs: {}
    } };
    this.observers = [];
  }
  import(nodes) {
    for (const n of nodes) {
      this.nodes[n.ID] = n;
    }
  }
  export() {
    const nodes = [];
    for (const n of Object.values(this.nodes)) {
      nodes.push(n);
    }
    return nodes;
  }
  new(name, value) {
    const id = name.startsWith("@") ? name : uniqueId();
    this.nodes[id] = {
      ID: id,
      Name: name,
      Value: value,
      Linked: { Children: [], Components: [] },
      Attrs: {}
    };
    return new Node(this, id);
  }
  destroy(n) {
    const p = n.getParent();
    if (p !== null) {
      p.raw.Linked.Children.splice(n.getSiblingIndex(), 1);
    }
    delete this.nodes[n.ID];
  }
  roots() {
    return Object.values(this.nodes).filter((n) => n.Parent === void 0).map((n) => new Node(this, n.ID));
  }
  changed(n) {
    this.observers.forEach((cb) => cb(n));
  }
  find(name) {
    for (const n of Object.values(this.nodes)) {
      if (n.Name === name) {
        return new Node(this, n.ID);
      }
    }
    return null;
  }
};
var uniqueId = () => {
  const dateString = Date.now().toString(36);
  const randomness = Math.random().toString(36).substring(2);
  return dateString + randomness;
};
function newNode(name) {
  return { ID: uniqueId(), Name: name, Linked: { Children: [] }, Attrs: {} };
}
function generateNodes(count) {
  const nodes = [];
  for (let i = 0; i < count; i++) {
    nodes.push(newNode(generateWords(randomNumber(2, 6))));
  }
  return nodes;
}
function generateNodeTree(count) {
  const nodes = {};
  const generated = generateNodes(count);
  generated.forEach((n) => {
    nodes[n.ID] = n;
    if (randomNumber(0, 4) > 0) {
      n.Parent = generated[randomNumber(0, count - 1)].ID;
    }
  });
  for (const [id, n] of Object.entries(nodes)) {
    if (n.Parent === n.ID) {
      n.Parent = void 0;
    }
    if (n.Parent) {
      nodes[n.Parent].Linked.Children.push(n.ID);
    }
  }
  return nodes;
}
var words = [
  "Got",
  "ability",
  "shop",
  "recall",
  "fruit",
  "easy",
  "dirty",
  "giant",
  "shaking",
  "ground",
  "weather",
  "lesson",
  "almost",
  "square",
  "forward",
  "bend",
  "cold",
  "broken",
  "distant",
  "adjective"
];
function getRandomWord(firstLetterToUppercase = false) {
  const word = words[randomNumber(0, words.length - 1)];
  return firstLetterToUppercase ? word.charAt(0).toUpperCase() + word.slice(1) : word;
}
function generateWords(length = 10) {
  return [...Array(length)].map((_, i) => getRandomWord(i === 0)).join(" ").trim();
}
function randomNumber(min, max) {
  return Math.round(Math.random() * (max - min) + min);
}

// lib/menu/mod.ts
var MenuRegistry = class {
  constructor() {
    this.menus = {};
  }
  registerMenu(id, items) {
    this.menus[id] = items;
  }
};

// lib/env/mod.ts
var Environment = class {
  constructor(backend) {
    this.workspace = new Workspace(this, backend);
    this.commands = new CommandRegistry();
    this.keybindings = new KeyBindings();
    this.menus = new MenuRegistry();
  }
};
var Workspace = class {
  constructor(env2, backend) {
    this.env = env2;
    this.backend = backend;
    this.manifold = new Module();
    const nodes = this.backend.loadAll();
    const root = this.manifold.find("@root");
    if (nodes.length === 0) {
      for (const n of Object.values(generateNodeTree(1e3))) {
        if (n.Parent === void 0) {
          n.Parent = "@root";
          root?.raw.Linked.Children.push(n.ID);
        }
        nodes.push(n);
      }
    }
    this.manifold.import(nodes);
    this.manifold.observers.push((n) => {
      this.backend.saveAll(Object.values(this.manifold.nodes));
    });
    this.context = { node: null };
  }
  setCurrentNode(n, pos = 0) {
    this.context.node = n;
    if (n) {
      document.getElementById(`input-${n.ID}`)?.focus();
      document.getElementById(`input-${n.ID}`)?.setSelectionRange(pos, pos);
    }
  }
  getContext(ctx) {
    return Object.assign({}, this.context, ctx);
  }
  showMenu(id, x, y, ctx) {
    const items = this.env.menus.menus[id];
    if (!items)
      return;
    this.menu = { x, y, ctx, items: items.map((i) => Object.assign(this.env.commands.commands[i.command], this.env.keybindings.getBinding(i.command))) };
    m.redraw();
  }
  hideMenu() {
    this.menu = null;
    m.redraw();
  }
};

// lib/ui/menu/mod.tsx
var Menu = {
  view({ attrs }) {
    const liStyle = {
      margin: "0px",
      listStyleType: "none",
      padding: "0.25rem 0.5rem 0.25rem 0.5rem",
      display: "flex"
    };
    const shortcutStyle = {
      flexGrow: "1",
      textAlign: "right",
      color: "#888",
      marginLeft: "1rem"
    };
    const onclick = (item) => (e) => {
      env.commands.executeCommand(item.command, env.workspace.getContext(attrs.ctx));
      env.workspace.hideMenu();
      e.stopPropagation();
    };
    return /* @__PURE__ */ m("ul", { class: "menu", style: {
      margin: "0",
      position: "absolute",
      left: `${attrs.x}px`,
      top: `${attrs.y}px`,
      border: "1px solid #555",
      borderRadius: "0.25rem",
      padding: "0.25rem 0 0.25rem 0",
      display: "inline-block",
      background: "white",
      filter: "drop-shadow(2px 2px 4px #5555)",
      fontSize: "14px",
      minWidth: "200px"
    } }, attrs.items.map((i) => /* @__PURE__ */ m("li", { onclick: onclick(i), style: liStyle }, /* @__PURE__ */ m("div", null, i.title), /* @__PURE__ */ m("div", { style: shortcutStyle }, i.key))));
  }
};

// lib/ui/app/mod.tsx
window.env = new Environment(new LocalStorageStore());
env.commands.registerCommand({
  id: "expand",
  title: "Expand",
  action: (ctx) => {
    if (!ctx.node)
      return;
    ctx.node.setAttr("expanded", JSON.stringify(true));
    m.redraw();
  }
});
env.keybindings.registerBinding({ command: "expand", key: "meta+arrowdown" });
env.commands.registerCommand({
  id: "collapse",
  title: "Collapse",
  action: (ctx) => {
    if (!ctx.node)
      return;
    ctx.node.setAttr("expanded", JSON.stringify(false));
    m.redraw();
  }
});
env.keybindings.registerBinding({ command: "collapse", key: "meta+arrowup" });
env.commands.registerCommand({
  id: "indent",
  title: "Indent",
  action: (ctx) => {
    if (!ctx.node)
      return;
    const prev = ctx.node.getPrevSibling();
    if (prev !== null) {
      ctx.node.setParent(prev);
      prev.setAttr("expanded", JSON.stringify(true));
      m.redraw.sync();
      env.workspace.setCurrentNode(ctx.node);
    }
  }
});
env.keybindings.registerBinding({ command: "indent", key: "tab" });
env.commands.registerCommand({
  id: "outdent",
  title: "Outdent",
  action: (ctx) => {
    if (!ctx.node)
      return;
    const parent = ctx.node.getParent();
    if (parent !== null && parent.ID !== "@root") {
      ctx.node.setParent(parent.getParent());
      ctx.node.setSiblingIndex(parent.getSiblingIndex() + 1);
      m.redraw.sync();
      env.workspace.setCurrentNode(ctx.node);
    }
  }
});
env.keybindings.registerBinding({ command: "outdent", key: "shift+tab" });
env.commands.registerCommand({
  id: "insert-child",
  title: "Insert Child",
  action: (ctx, name = "") => {
    if (!ctx.node)
      return;
    const node = env.workspace.manifold.new(name);
    node.setParent(ctx.node);
    m.redraw.sync();
    env.workspace.setCurrentNode(node, name.length);
  }
});
env.commands.registerCommand({
  id: "insert-before",
  title: "Insert Before",
  action: (ctx) => {
    if (!ctx.node)
      return;
    const node = env.workspace.manifold.new("");
    node.setParent(ctx.node.getParent());
    node.setSiblingIndex(ctx.node.getSiblingIndex());
    m.redraw.sync();
    env.workspace.setCurrentNode(node);
  }
});
env.commands.registerCommand({
  id: "insert",
  title: "Insert Node",
  action: (ctx, name = "") => {
    if (!ctx.node)
      return;
    const node = env.workspace.manifold.new(name);
    node.setParent(ctx.node.getParent());
    node.setSiblingIndex(ctx.node.getSiblingIndex() + 1);
    m.redraw.sync();
    env.workspace.setCurrentNode(node);
  }
});
env.keybindings.registerBinding({ command: "insert", key: "shift+enter" });
env.commands.registerCommand({
  id: "delete",
  title: "Delete node",
  action: (ctx) => {
    if (!ctx.node)
      return;
    const prev = ctx.node.getPrevSibling();
    ctx.node.destroy();
    m.redraw.sync();
    if (prev) {
      env.workspace.setCurrentNode(prev);
    }
  }
});
env.keybindings.registerBinding({ command: "delete", key: "shift+meta+backspace" });
env.commands.registerCommand({
  id: "prev",
  action: (ctx) => {
    if (!ctx.node)
      return;
    const prev = ctx.node.getPrevSibling();
    if (prev !== null) {
      env.workspace.setCurrentNode(prev);
    } else {
      env.workspace.setCurrentNode(ctx.node.getParent());
    }
  }
});
env.keybindings.registerBinding({ command: "prev", key: "arrowup" });
env.commands.registerCommand({
  id: "next",
  action: (ctx) => {
    if (!ctx.node)
      return;
    const next = ctx.node.getNextSibling();
    if (next !== null) {
      env.workspace.setCurrentNode(next);
    } else {
      env.workspace.setCurrentNode(ctx.node.getParent().getNextSibling());
    }
  }
});
env.keybindings.registerBinding({ command: "next", key: "arrowdown" });
env.menus.registerMenu("node", [
  { command: "indent" },
  { command: "outdent" },
  { command: "delete" }
]);
document.addEventListener("keydown", (e) => {
  const binding = env.keybindings.evaluateEvent(e);
  if (binding && env.workspace.context.node) {
    env.commands.executeCommand(binding.command, env.workspace.context);
    e.stopPropagation();
    e.preventDefault();
  }
});
document.addEventListener("click", (e) => {
  env.workspace.hideMenu();
});
var App = {
  view(vnode) {
    const reset = (e) => {
      localStorage.clear();
      location.reload();
    };
    return /* @__PURE__ */ m("main", null, /* @__PURE__ */ m("button", { onclick: reset }, "Reset"), env.workspace.manifold.find("@root").getChildren().map((n) => /* @__PURE__ */ m(OutlineNode, { key: n.ID, data: n })), env.workspace.menu && /* @__PURE__ */ m(Menu, { ...env.workspace.menu }));
  }
};
export {
  App
};
