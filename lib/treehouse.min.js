var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// lib/action/keybinds.ts
var isMac = navigator.userAgent.toLowerCase().indexOf("mac") !== -1;
function bindingSymbols(key) {
  if (!key)
    return [];
  const symbols = {
    "backspace": "\u232B",
    "shift": "\u21E7",
    "meta": "\u2318",
    "tab": "\u21B9",
    "ctrl": "\u2303",
    "arrowup": "\u2191",
    "arrowdown": "\u2193",
    "arrowleft": "\u2190",
    "arrowright": "\u2192",
    "enter": "\u23CE"
  };
  const keys = key.toLowerCase().split("+");
  return keys.map(filterKeyForNonMacMeta).map((k) => Object.keys(symbols).includes(k) ? symbols[k] : k);
}
function filterKeyForNonMacMeta(key) {
  return !isMac && key === "meta" ? "ctrl" : key;
}
var KeyBindings = class {
  constructor() {
    this.bindings = [];
  }
  registerBinding(binding) {
    this.bindings.push(binding);
  }
  getBinding(commandId) {
    for (const b of this.bindings) {
      if (b.command === commandId) {
        return b;
      }
    }
    return null;
  }
  evaluateEvent(event) {
    bindings:
      for (const b of this.bindings) {
        let modifiers = b.key.toLowerCase().split("+");
        let key = modifiers.pop();
        if (key !== event.key.toLowerCase()) {
          continue;
        }
        for (const checkMod of ["shift", "ctrl", "alt", "meta"]) {
          let hasMod = modifiers.includes(checkMod);
          if (!isMac) {
            if (checkMod === "meta")
              continue;
            if (checkMod === "ctrl") {
              hasMod = modifiers.includes("meta") || modifiers.includes("ctrl");
            }
          }
          const modState = event[`${filterKeyForNonMacMeta(checkMod)}Key`];
          if (!modState && hasMod) {
            continue bindings;
          }
          if (modState && !hasMod) {
            continue bindings;
          }
        }
        return b;
      }
    return null;
  }
};

// lib/action/commands.ts
var CommandRegistry = class {
  constructor() {
    this.commands = {};
  }
  registerCommand(cmd) {
    this.commands[cmd.id] = cmd;
  }
  executeCommand(id, ...rest) {
    return new Promise((resolve) => {
      const ret = this.commands[id].action(...rest);
      resolve(ret);
    });
  }
};

// lib/manifold/components.ts
var registry = {};
function component(target) {
  const stack = new Error().stack;
  if (stack) {
    const line = stack.split("\n")[3];
    const name = line.split("/").pop()?.split(".")[0];
    target.__module = name;
  }
  registry[componentName(target)] = target;
}
function componentName(target) {
  if (target.constructor && target.constructor.__module) {
    target = target.constructor;
  }
  if (target.__module) {
    return `${target.__module}.${target.name}`;
  }
  return target.name;
}

// lib/manifold/mod.ts
var Node = class {
  constructor(module, id) {
    this.module = module;
    this.ID = id;
  }
  changed() {
    this.module.changed(this);
  }
  get isDestroyed() {
    return !this.module.nodes.hasOwnProperty(this.ID);
  }
  get raw() {
    return this.module.nodes[this.ID];
  }
  getName() {
    return this.raw.Name;
  }
  setName(val) {
    this.raw.Name = val;
    this.changed();
  }
  getValue() {
    return this.raw.Value;
  }
  getParent() {
    if (!this.raw.Parent)
      return null;
    return new Node(this.module, this.raw.Parent);
  }
  setParent(n) {
    const p = this.getParent();
    if (p !== null) {
      p.raw.Linked.Children.splice(this.getSiblingIndex(), 1);
    }
    this.raw.Parent = n.ID;
    n.raw.Linked.Children.push(this.ID);
    this.changed();
  }
  getChildren() {
    if (!this.raw.Linked.Children)
      return [];
    return this.raw.Linked.Children.map((id) => new Node(this.module, id));
  }
  childCount() {
    if (!this.raw.Linked.Children)
      return 0;
    return this.raw.Linked.Children.length;
  }
  getAttr(name) {
    return this.raw.Attrs[name] || "";
  }
  setAttr(name, value) {
    this.raw.Attrs[name] = value;
    this.changed();
  }
  getSiblingIndex() {
    const p = this.getParent();
    if (p === null)
      return 0;
    return p.raw.Linked.Children.findIndex((id) => id === this.ID);
  }
  setSiblingIndex(i) {
    const p = this.getParent();
    if (p === null)
      return;
    p.raw.Linked.Children.splice(this.getSiblingIndex(), 1);
    p.raw.Linked.Children.splice(i, 0, this.ID);
    p.changed();
  }
  getPrevSibling() {
    const p = this.getParent();
    if (p === null)
      return null;
    if (this.getSiblingIndex() === 0)
      return null;
    return p.getChildren()[this.getSiblingIndex() - 1];
  }
  getNextSibling() {
    const p = this.getParent();
    if (p === null)
      return null;
    if (this.getSiblingIndex() === p.getChildren().length - 1)
      return null;
    return p.getChildren()[this.getSiblingIndex() + 1];
  }
  destroy() {
    const nodes = [];
    this.walk((n) => {
      nodes.push(n);
      return false;
    });
    nodes.reverse().forEach((n) => this.module.destroy(n));
  }
  addComponent(obj) {
    const node = this.module.new(componentName(obj), obj);
    node.raw.Parent = this.ID;
    this.raw.Linked.Components.push(node.ID);
    this.changed();
  }
  removeComponent(type) {
    const coms = this.getComponentNodes().filter((n) => n.getName() === componentName(type));
    if (coms.length > 0) {
      coms[0].destroy();
    }
    this.changed();
  }
  hasComponent(type) {
    const coms = this.getComponentNodes().filter((n) => n.getName() === componentName(type));
    if (coms.length > 0) {
      return true;
    }
    return false;
  }
  getComponent(type) {
    const coms = this.getComponentNodes().filter((n) => n.getName() === componentName(type));
    if (coms.length > 0) {
      return coms[0].getValue();
    }
    return null;
  }
  getComponentNodes() {
    if (!this.raw.Linked.Components)
      return [];
    return this.raw.Linked.Components.map((id) => new Node(this.module, id));
  }
  getPath() {
    let cur = this;
    const path = [];
    while (cur) {
      path.unshift(cur.getName());
      cur = cur.getParent();
    }
    return path.join("/");
  }
  find(path) {
    return this.module.find([this.getPath(), path].join("/"));
  }
  walk(cb) {
    if (cb(this)) {
      return true;
    }
    for (const child of this.getChildren()) {
      if (child.walk(cb))
        return true;
    }
    return false;
  }
  // getComponentsInChildren
  // getComponentsInParents
  // getAncestors
  // getPath
  // duplicate?
};
var Module = class {
  constructor() {
    this.nodes = { "@root": {
      ID: "@root",
      Name: "@root",
      Linked: { Children: [], Components: [] },
      Attrs: {}
    } };
    this.observers = [];
  }
  import(nodes) {
    for (const n of nodes) {
      this.nodes[n.ID] = n;
    }
  }
  export() {
    const nodes = [];
    for (const n of Object.values(this.nodes)) {
      nodes.push(n);
    }
    return nodes;
  }
  new(name, value) {
    let parent = null;
    if (name.includes("/")) {
      let start = 0;
      const parts = name.split("/");
      if (name.startsWith("@")) {
        parent = this.find(parts[0]);
        start = 1;
      } else {
        parent = this.getRoot();
      }
      for (let i = start; i < parts.length - 1; i++) {
        if (parent === null) {
          throw "unable to get root";
        }
        let child = parent.find(parts[i]);
        if (!child) {
          child = this.new(parts.slice(0, i + 1).join("/"));
        }
        parent = child;
      }
      name = parts[parts.length - 1];
    }
    const id = name.startsWith("@") ? name : uniqueId();
    this.nodes[id] = {
      ID: id,
      Name: name,
      Value: value,
      Linked: { Children: [], Components: [] },
      Attrs: {}
    };
    const node = new Node(this, id);
    if (parent) {
      node.setParent(parent);
    }
    return node;
  }
  destroy(n) {
    const p = n.getParent();
    if (p !== null) {
      if (p.raw.Linked.Children.includes(n.ID)) {
        p.raw.Linked.Children.splice(n.getSiblingIndex(), 1);
      }
      if (p.raw.Linked.Components.includes(n.ID)) {
        p.raw.Linked.Components.splice(n.getSiblingIndex(), 1);
      }
    }
    delete this.nodes[n.ID];
    if (p) {
      this.changed(p);
    }
  }
  roots() {
    return Object.values(this.nodes).filter((n) => n.Parent === void 0).map((n) => new Node(this, n.ID));
  }
  changed(n) {
    this.observers.forEach((cb) => cb(n));
  }
  getRoot(name) {
    name = name || "@root";
    const node = this.roots().find((root) => root.getName() === name);
    if (node === void 0)
      return null;
    return node;
  }
  find(path) {
    const byId = this.nodes[path];
    if (byId)
      return new Node(this, byId.ID);
    const parts = path.split("/");
    if (parts.length === 1 && parts[0].startsWith("@")) {
      return null;
    }
    let anchorName = "@root";
    if (parts[0].startsWith("@")) {
      anchorName = parts.shift();
    }
    const findChild = (n, name) => {
      return n.getChildren().find((child) => child.getName() === name);
    };
    let cur = this.find(anchorName);
    if (!cur) {
      return null;
    }
    for (const name of parts) {
      const child = findChild(cur, name);
      if (!child)
        return null;
      cur = child;
    }
    return cur;
  }
  walk(cb) {
    for (const root of this.roots()) {
      if (root.walk(cb))
        return;
    }
  }
};
var uniqueId = () => {
  const dateString = Date.now().toString(36);
  const randomness = Math.random().toString(36).substring(2);
  return dateString + randomness;
};

// lib/action/menus.ts
var MenuRegistry = class {
  constructor() {
    this.menus = {};
  }
  registerMenu(id, items) {
    this.menus[id] = items;
  }
};

// lib/workbench.ts
var Panel = class {
  constructor(head) {
    this.id = Math.random().toString(36).substring(2);
    this.history = [head];
  }
  open(node) {
    this.history.push(node);
  }
  back() {
    this.history.pop();
  }
  get currentNode() {
    return this.history[this.history.length - 1];
  }
  get headNode() {
    return this.history[0];
  }
};
var Workspace = class {
  // [rootid][id]
  constructor(fs) {
    this.fs = fs;
    this.module = new Module();
    this.expanded = {};
    this.writeDebounce = debounce(async (path, contents) => {
      try {
        await this.fs.writeFile(path, contents);
        console.log("Saved workspace.");
      } catch (e) {
        console.error(e);
        document.dispatchEvent(new CustomEvent("BackendError"));
      }
    });
  }
  get rawNodes() {
    return Object.values(this.module.nodes);
  }
  get observers() {
    return this.module.observers;
  }
  save() {
    this.writeDebounce("workspace.json", JSON.stringify({
      version: 1,
      lastopen: this.lastOpenedID,
      expanded: this.expanded,
      nodes: this.rawNodes
    }, null, 2));
  }
  async load() {
    let doc = JSON.parse(await this.fs.readFile("workspace.json") || "{}");
    if (Array.isArray(doc)) {
      doc = {
        version: 0,
        nodes: doc
      };
    }
    if (doc.nodes) {
      this.module.import(doc.nodes);
    }
    if (doc.expanded) {
      this.expanded = doc.expanded;
    }
    if (doc.lastopen) {
      this.lastOpenedID = doc.lastopen;
    }
  }
  mainNode() {
    let main = this.module.find("@workspace");
    if (!main) {
      const root = this.module.find("@root");
      const ws = this.module.new("@workspace");
      ws.setName("Workspace");
      ws.setParent(root);
      const cal = this.module.new("@calendar");
      cal.setName("Calendar");
      cal.setParent(ws);
      const home = this.module.new("Home");
      home.setParent(ws);
      main = ws;
    }
    return main;
  }
  find(path) {
    return this.module.find(path);
  }
  new(name, value) {
    return this.module.new(name, value);
  }
  getExpanded(head, n) {
    if (!this.expanded[head.ID]) {
      this.expanded[head.ID] = {};
    }
    let expanded = this.expanded[head.ID][n.ID];
    if (expanded === void 0) {
      expanded = false;
    }
    return expanded;
  }
  setExpanded(head, n, b) {
    this.expanded[head.ID][n.ID] = b;
    this.save();
  }
  findAbove(head, n) {
    if (n.ID === head.ID) {
      return null;
    }
    let above = n.getPrevSibling();
    if (!above) {
      return n.getParent();
    }
    const lastChildIfExpanded = (n2) => {
      const expanded = this.getExpanded(head, n2);
      if (!expanded || n2.childCount() === 0) {
        return n2;
      }
      const lastChild = n2.getChildren()[n2.childCount() - 1];
      return lastChildIfExpanded(lastChild);
    };
    return lastChildIfExpanded(above);
  }
  findBelow(head, n) {
    if (this.getExpanded(head, n) && n.childCount() > 0) {
      return n.getChildren()[0];
    }
    const nextSiblingOrParentNextSibling = (n2) => {
      const below = n2.getNextSibling();
      if (below) {
        return below;
      }
      const parent = n2.getParent();
      if (!parent || parent.ID === head.ID) {
        return null;
      }
      return nextSiblingOrParentNextSibling(parent);
    };
    return nextSiblingOrParentNextSibling(n);
  }
};
function debounce(func, timeout = 3e3) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, timeout);
  };
}
var Workbench = class {
  constructor(backend) {
    this.commands = new CommandRegistry();
    this.keybindings = new KeyBindings();
    this.menus = new MenuRegistry();
    this.backend = backend;
    this.workspace = new Workspace(backend.files);
    this.context = { node: null };
    this.panels = [[]];
  }
  get mainPanel() {
    return this.panels[0][0];
  }
  async initialize() {
    await this.workspace.load();
    this.workspace.rawNodes.forEach((n) => this.backend.index.index(n));
    this.workspace.observers.push((n) => {
      this.workspace.save();
      this.backend.index.index(n.raw);
      n.getComponentNodes().forEach((com) => this.backend.index.index(com.raw));
    });
    if (this.workspace.lastOpenedID) {
      this.openNewPanel(this.workspace.find(this.workspace.lastOpenedID) || this.workspace.mainNode());
    } else {
      this.openNewPanel(this.workspace.mainNode());
    }
    m.redraw();
    if (!localStorage.getItem("firsttime")) {
      this.showNotice("firsttime");
    }
  }
  authenticated() {
    return this.backend.auth && this.backend.auth.currentUser();
  }
  closeQuickAdd() {
    this.quickadd = null;
    m.redraw();
  }
  openQuickAdd() {
    let node = this.workspace.find("@quickadd");
    if (!node) {
      node = this.workspace.new("@quickadd");
    }
    this.quickadd = node;
  }
  commitQuickAdd() {
    const node = this.workspace.find("@quickadd");
    if (!node)
      return;
    const today = this.todayNode();
    node.getChildren().forEach((n) => n.setParent(today));
  }
  clearQuickAdd() {
    const node = this.workspace.find("@quickadd");
    if (!node)
      return;
    node.getChildren().forEach((n) => n.destroy());
  }
  // TODO: goto workspace
  todayNode() {
    const today = new Date();
    const dayNode = today.toUTCString().split(today.getFullYear())[0];
    const weekNode = `Week ${String(getWeekOfYear(today)).padStart(2, "0")}`;
    const yearNode = `${today.getFullYear()}`;
    const todayPath = ["@workspace", "Calendar", yearNode, weekNode, dayNode].join("/");
    let todayNode = this.workspace.find(todayPath);
    if (!todayNode) {
      todayNode = this.workspace.new(todayPath);
    }
    return todayNode;
  }
  openToday() {
    this.open(this.todayNode());
  }
  open(n) {
    if (!this.workspace.expanded[n.ID]) {
      this.workspace.expanded[n.ID] = {};
    }
    this.workspace.lastOpenedID = n.ID;
    this.workspace.save();
    const p = new Panel(n);
    this.panels[0][0] = p;
    this.context.panel = p;
  }
  openNewPanel(n) {
    if (!this.workspace.expanded[n.ID]) {
      this.workspace.expanded[n.ID] = {};
    }
    this.workspace.lastOpenedID = n.ID;
    this.workspace.save();
    const p = new Panel(n);
    this.panels[0].push(p);
    this.context.panel = p;
  }
  closePanel(panel) {
    this.panels.forEach((row, ridx) => {
      this.panels[ridx] = row.filter((p) => p !== panel);
    });
  }
  defocus() {
    this.context.node = null;
  }
  focus(n, panel, pos = 0) {
    this.context.node = n;
    if (panel) {
      this.context.panel = panel;
    }
    const input = this.getInput(n, panel);
    if (input) {
      input.focus();
      if (pos !== void 0) {
        input.setSelectionRange(pos, pos);
      }
    }
  }
  getInput(n, panel) {
    if (!panel) {
      panel = this.context.panel;
    }
    return document.getElementById(`input-${panel.id}-${n.ID}`);
  }
  executeCommand(id, ctx, ...rest) {
    return this.commands.executeCommand(id, this.newContext(ctx), ...rest);
  }
  newContext(ctx) {
    return Object.assign({}, this.context, ctx);
  }
  showMenu(event, ctx) {
    event.stopPropagation();
    event.preventDefault();
    const trigger = event.target.closest("*[data-menu]");
    const rect = trigger.getBoundingClientRect();
    const align = trigger.dataset["align"] || "left";
    let x = document.body.scrollLeft + rect.x;
    if (align === "right") {
      x = document.body.offsetWidth - rect.right;
    }
    const y = document.body.scrollTop + rect.y + rect.height;
    const items = this.menus.menus[trigger.dataset["menu"]];
    const cmds = items.filter((i) => i.command).map((i) => this.commands.commands[i.command]);
    if (!items)
      return;
    this.menu = {
      x,
      y,
      ctx: this.newContext(ctx),
      items,
      commands: cmds,
      align
    };
    this.curtain = {
      visible: false,
      onclick: () => this.hideMenu()
    };
    m.redraw();
  }
  hideMenu() {
    this.menu = null;
    this.curtain = null;
    m.redraw();
  }
  showPalette(x, y, ctx) {
    this.palette = { x, y, ctx };
    this.curtain = {
      visible: false,
      onclick: () => this.hidePalette()
    };
    m.redraw();
  }
  hidePalette() {
    this.palette = null;
    this.curtain = null;
    m.redraw();
  }
  showNotice(message, finished) {
    this.notice = { message, finished };
    m.redraw();
  }
  hideNotice() {
    this.notice = null;
    m.redraw();
  }
};
function getWeekOfYear(date) {
  var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  var dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil(((d - yearStart) / 864e5 + 1) / 7);
}

// lib/ui/menu.tsx
var Menu = {
  view({ attrs: { workbench, x, y, items, align, commands, ctx } }) {
    const onclick = (item, cmd) => (e) => {
      e.stopPropagation();
      if (item.disabled) {
        return;
      }
      if (item.onclick) {
        item.onclick();
      }
      if (cmd) {
        workbench.executeCommand(cmd.id, ctx);
      }
      workbench.hideMenu();
    };
    let posStyle = { left: `${x}px` };
    if (align === "right") {
      posStyle = { right: `${x}px` };
    }
    return /* @__PURE__ */ m("ul", { class: "menu", style: Object.assign(posStyle, {
      margin: "0",
      position: "absolute",
      top: `${y}px`,
      border: "1px solid var(--dark)",
      borderRadius: "0.25rem",
      padding: "0.25rem 0 0.25rem 0",
      display: "inline-block",
      background: "white",
      filter: "drop-shadow(2px 2px 4px #5555)",
      fontSize: "14px",
      minWidth: "200px",
      zIndex: "20"
    }) }, items.filter((i) => !i.when || i.when()).map((i) => {
      let title = "";
      let binding = void 0;
      let cmd = void 0;
      if (i.command) {
        cmd = commands.find((c) => c.id === i.command);
        binding = workbench.keybindings.getBinding(cmd.id);
        title = cmd.title;
      }
      if (i.title) {
        title = i.title();
      }
      return /* @__PURE__ */ m("li", { onclick: onclick(i, cmd), class: i.disabled ? "disabled" : "", style: {
        margin: "0px",
        listStyleType: "none",
        padding: "0.25rem 0.5rem 0.25rem 0.5rem",
        display: "flex"
      } }, /* @__PURE__ */ m("div", null, title), binding && /* @__PURE__ */ m("div", { style: {
        flexGrow: "1",
        textAlign: "right",
        color: "#888",
        marginLeft: "1rem"
      } }, bindingSymbols(binding.key).join(" ").toUpperCase()));
    }));
  }
};

// lib/ui/palette.tsx
var CommandPalette = {
  onupdate({ state, dom }) {
    const children = dom.querySelector(".commands").children;
    if (state.selected !== void 0 && children.length > 0) {
      children[state.selected].scrollIntoView({ block: "nearest" });
    }
  },
  oncreate({ dom }) {
    dom.querySelector("input").focus();
  },
  view({ attrs, state }) {
    const workbench = attrs.workbench;
    state.filter = state.filter === void 0 ? "" : state.filter;
    const cmds = Object.values(workbench.commands.commands);
    const filtered = cmds.filter((cmd) => cmd.id.startsWith(state.filter));
    const onkeydown = (e) => {
      const mod = (a, b) => (a % b + b) % b;
      if (e.key === "ArrowDown") {
        if (state.selected === void 0) {
          state.selected = 0;
          return;
        }
        state.selected = mod(state.selected + 1, filtered.length);
        return false;
      }
      if (e.key === "ArrowUp") {
        if (state.selected === void 0) {
          state.selected = 0;
        }
        state.selected = mod(state.selected - 1, filtered.length);
        return false;
      }
      if (e.key === "Enter") {
        if (state.selected !== void 0) {
          workbench.commands.executeCommand(filtered[state.selected].id, attrs.ctx);
          workbench.hidePalette();
        }
        return false;
      }
    };
    const autocomplete = (e) => {
      state.filter = e.target.value;
      state.selected = 0;
    };
    return /* @__PURE__ */ m("div", { class: "palette", style: {
      margin: "0",
      position: "absolute",
      left: `${attrs.x}px`,
      top: `${attrs.y}px`,
      border: "1px solid var(--dark)",
      borderRadius: "0.25rem",
      padding: "0.5rem",
      background: "white",
      fontSize: "14px",
      minWidth: "400px",
      zIndex: "20"
    } }, /* @__PURE__ */ m("div", null, /* @__PURE__ */ m("input", { style: { width: "98%", outline: "0", border: "0" }, type: "text", onkeydown, oninput: autocomplete, placeholder: "Enter command..." })), /* @__PURE__ */ m("div", { class: "commands", style: {
      margin: "0.25rem",
      overflowY: "scroll",
      maxHeight: "200px",
      position: "relative"
    } }, filtered.map((cmd, idx) => /* @__PURE__ */ m("div", { style: { padding: "0.25rem" }, class: state.selected === idx ? "selected" : "" }, cmd.title || cmd.id))));
  }
};

// lib/ui/outline.tsx
var OutlineNode = {
  view({ attrs, state, children }) {
    const { node, panel, workbench } = attrs;
    const expanded = workbench.workspace.getExpanded(panel.headNode, node);
    const hover = (e) => {
      state.hover = true;
      e.stopPropagation();
    };
    const unhover = (e) => {
      state.hover = false;
      e.stopPropagation();
    };
    const toggle = (e) => {
      if (expanded) {
        workbench.executeCommand("collapse", { node, panel });
      } else {
        workbench.executeCommand("expand", { node, panel });
      }
      e.stopPropagation();
    };
    const checkCommands = (e) => {
      const anyModifiers = e.shiftKey || e.metaKey || e.altKey || e.ctrlKey;
      switch (e.key) {
        case "ArrowUp":
          if (e.target.selectionStart !== 0 && !anyModifiers) {
            e.stopPropagation();
          }
          break;
        case "ArrowDown":
          if (e.target.selectionStart !== e.target.value.length && e.target.selectionStart !== 0 && !anyModifiers) {
            e.stopPropagation();
          }
          break;
        case "Backspace":
          if (e.target.value === "") {
            e.preventDefault();
            e.stopPropagation();
            if (node.childCount() > 0) {
              return;
            }
            workbench.executeCommand("delete", { node, panel, event: e });
            return;
          }
          if (e.target.value !== "" && e.target.selectionStart === 0 && e.target.selectionEnd === 0) {
            e.preventDefault();
            e.stopPropagation();
            const prev = workbench.workspace.findAbove(panel.headNode, node);
            if (!prev) {
              return;
            }
            const oldName = prev.getName();
            prev.setName(oldName + e.target.value);
            node.destroy();
            m.redraw.sync();
            workbench.focus(prev, panel, oldName.length);
            return;
          }
          break;
        case "Enter":
          e.preventDefault();
          if (e.ctrlKey || e.shiftKey || e.metaKey || e.altKey)
            return;
          if (e.target.selectionStart === e.target.value.length) {
            if (node.childCount() > 0 && workbench.workspace.getExpanded(panel.headNode, node)) {
              workbench.executeCommand("insert-child", { node, panel }, "", 0);
            } else {
              workbench.executeCommand("insert", { node, panel });
            }
            e.stopPropagation();
            return;
          }
          if (e.target.selectionStart === 0) {
            workbench.executeCommand("insert-before", { node, panel });
            e.stopPropagation();
            return;
          }
          if (e.target.selectionStart > 0 && e.target.selectionStart < e.target.value.length) {
            workbench.executeCommand("insert", { node, panel }, e.target.value.slice(e.target.selectionStart)).then(() => {
              node.setName(e.target.value.slice(0, e.target.selectionStart));
            });
            e.stopPropagation();
            return;
          }
          break;
      }
    };
    const toggleCheckbox = (e) => {
      const checkbox = node.getComponent(Checkbox);
      checkbox.checked = !checkbox.checked;
      node.changed();
    };
    const open = (e) => {
      e.preventDefault();
      e.stopPropagation();
      workbench.executeCommand("open", { node, panel });
      if (document.selection && document.selection.empty) {
        document.selection.empty();
      } else if (window.getSelection) {
        window.getSelection().removeAllRanges();
      }
    };
    return /* @__PURE__ */ m("div", { onmouseover: hover, onmouseout: unhover }, /* @__PURE__ */ m("div", { style: {
      display: "flex",
      flexDirection: "row",
      alignItems: "start",
      marginTop: "0.125rem",
      marginBottom: "0.125rem"
    } }, /* @__PURE__ */ m(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        style: {
          cursor: "pointer",
          flexShrink: "0",
          width: "1rem",
          height: "1rem",
          position: "absolute",
          marginLeft: "-1rem",
          userSelect: "none",
          marginTop: "0.25rem",
          display: state.hover ? "block" : "none"
        },
        onclick: (e) => workbench.showMenu(e, { node, panel }),
        oncontextmenu: (e) => workbench.showMenu(e, { node, panel }),
        "data-menu": "node",
        fill: "lightgray",
        viewBox: "0 0 16 16"
      },
      /* @__PURE__ */ m("path", { style: { transform: "translateY(-1px)" }, "fill-rule": "evenodd", d: "M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5zm0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5z" })
    ), /* @__PURE__ */ m("svg", { onclick: toggle, ondblclick: open, oncontextmenu: (e) => workbench.showMenu(e, { node, panel }), "data-menu": "node", style: {
      cursor: "pointer",
      flexShrink: "0",
      width: "1rem",
      height: "1rem",
      marginRight: "0.5rem",
      paddingLeft: "1px",
      marginTop: "0.25rem"
    }, xmlns: "http://www.w3.org/2000/svg", fill: "gray", viewBox: "0 0 16 16" }, node.childCount() > 0 && !expanded ? /* @__PURE__ */ m("circle", { cx: "8", cy: "7", r: "7", fill: "lightgray" }) : null, /* @__PURE__ */ m("circle", { cx: "8", cy: "7", r: "3" })), /* @__PURE__ */ m("div", { style: { flexGrow: "1", display: "flex", alignItems: "start" } }, node.hasComponent(Checkbox) ? /* @__PURE__ */ m("input", { type: "checkbox", style: { marginTop: "0.3rem", marginRight: "0.5rem" }, onclick: toggleCheckbox, checked: node.getComponent(Checkbox).checked }) : null, /* @__PURE__ */ m(NodeEditor, { workbench, panel, node, onkeydown: checkCommands }))), expanded === true && /* @__PURE__ */ m("div", { style: {
      display: "flex",
      flexDirection: "row",
      paddingBottom: "0.25rem"
    } }, /* @__PURE__ */ m("div", { style: { width: "var(--8)", display: "flex" }, onclick: toggle }), /* @__PURE__ */ m("div", { style: { flexGrow: "1" } }, node.childCount() > 0 ? node.getChildren().map((n) => /* @__PURE__ */ m(OutlineNode, { key: n.ID, workbench, panel, node: n })) : /* @__PURE__ */ m(NewNode, { workbench, panel, node }))));
  }
};
var NewNode = {
  view({ attrs: { workbench, panel, node } }) {
    const startNew = (e) => {
      workbench.executeCommand("insert-child", { node, panel }, e.target.value);
    };
    const tabNew = (e) => {
      if (e.key === "Tab") {
        e.stopPropagation();
        e.preventDefault();
        if (node.childCount() > 0) {
          const lastchild = node.getChildren()[node.childCount() - 1];
          workbench.executeCommand("insert-child", { node: lastchild, panel });
        }
      }
    };
    return /* @__PURE__ */ m("div", { style: {
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      marginTop: "0.125rem",
      marginBottom: "0.125rem"
    } }, /* @__PURE__ */ m("svg", { style: { flexShrink: "0", width: "1rem", height: "1rem", marginRight: "0.5rem", paddingLeft: "1px" }, xmlns: "http://www.w3.org/2000/svg", fill: "gray", viewBox: "0 0 16 16" }, /* @__PURE__ */ m("circle", { cx: "8", cy: "7", r: "7", fill: "lightgray" }), /* @__PURE__ */ m("path", { fill: "#555", style: { transform: "translate(0px, -1px)" }, d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" })), /* @__PURE__ */ m("div", { style: { flexGrow: "1", display: "flex" } }, /* @__PURE__ */ m(
      "input",
      {
        type: "text",
        oninput: startNew,
        onkeydown: tabNew,
        value: "",
        style: {
          border: "0px",
          flexGrow: "1",
          outline: "0px"
        }
      }
    )));
  }
};
var OutlineEditor = {
  view({ attrs: { workbench, panel, node }, state }) {
    return /* @__PURE__ */ m("div", { style: { color: "var(--gray-900)" } }, node.getChildren().map((n) => /* @__PURE__ */ m(OutlineNode, { key: n.ID, workbench, panel, node: n })), /* @__PURE__ */ m(NewNode, { workbench, panel, node }));
  }
};
var NodeEditor = {
  oncreate({ dom }) {
    const textarea = dom.querySelector("textarea");
    const initialHeight = textarea.offsetHeight;
    const span = dom.querySelector("span");
    this.updateHeight = () => {
      span.style.width = `${Math.max(textarea.offsetWidth, 100)}px`;
      span.innerHTML = textarea.value.replace("\n", "<br/>");
      textarea.style.height = span.offsetHeight > 0 ? `${span.offsetHeight}px` : `${initialHeight}px`;
    };
    textarea.addEventListener("input", () => this.updateHeight());
    textarea.addEventListener("blur", () => span.innerHTML = "");
    setTimeout(() => this.updateHeight(), 50);
  },
  onupdate() {
    this.updateHeight();
  },
  view({ attrs: { workbench, node, panel, onkeydown, disallowEmpty }, state }) {
    const value = state.editing ? state.buffer : node.getName();
    const defaultKeydown = (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    const startEdit = (e) => {
      state.initialValue = node.getName();
      workbench.context.node = node;
      state.editing = true;
      state.buffer = node.getName();
    };
    const finishEdit = (e) => {
      if (state.editing) {
        state.editing = false;
        if (!node.isDestroyed) {
          if (disallowEmpty && state.buffer.length === 0) {
            node.setName(state.initialValue);
          } else {
            node.setName(state.buffer);
          }
        }
        state.buffer = void 0;
        workbench.context.node = null;
      }
    };
    const edit = (e) => {
      state.buffer = e.target.value;
      if (disallowEmpty && state.buffer.length === 0) {
        node.setName(state.initialValue);
      } else {
        node.setName(state.buffer);
      }
    };
    const style = {
      outline: "none",
      color: "inherit",
      fontSize: "inherit",
      fontWeight: "inherit",
      fontFamily: "inherit",
      padding: "0",
      width: "100%",
      boxSizing: "border-box",
      resize: "none",
      overflow: "hidden",
      display: "block",
      lineHeight: "1.45",
      border: "none"
    };
    return /* @__PURE__ */ m("div", { style: { width: "100%", marginBottom: "0.5rem" } }, /* @__PURE__ */ m(
      "textarea",
      {
        style,
        id: `input-${panel.id}-${node.ID}`,
        rows: "1",
        onfocus: startEdit,
        onblur: finishEdit,
        oninput: edit,
        onkeydown: onkeydown || defaultKeydown,
        value
      },
      value
    ), /* @__PURE__ */ m("span", { style: Object.assign({ visibility: "hidden", position: "fixed" }, style) }));
  }
};

// lib/ui/panel.tsx
var Panel2 = {
  view({ attrs }) {
    const panel = attrs.panel;
    const workbench = attrs.workbench;
    const node = panel.currentNode;
    const close = (e) => {
      workbench.executeCommand("close-panel", {}, panel);
    };
    const goBack = (e) => {
      panel.back();
    };
    const maximize = (e) => {
      workbench.panels = [[panel]];
      workbench.context.panel = panel;
    };
    const editMarkdown = (e) => {
      node.getComponent(Page).markdown = e.target.value;
      node.changed();
    };
    function calcHeight(value = "") {
      let numberOfLineBreaks = (value.match(/\n/g) || []).length;
      let newHeight = 20 + numberOfLineBreaks * 20;
      return newHeight;
    }
    return /* @__PURE__ */ m("div", { class: "panel flex flex-col grow", style: {
      marginTop: "var(--4)",
      marginLeft: "var(--12)",
      marginRight: "var(--12)",
      paddingBottom: "var(--padding)"
    } }, /* @__PURE__ */ m("div", { class: "bar", style: {
      display: "flex",
      fontSize: "0.875rem",
      color: "var(--gray-600)",
      gap: "var(--padding)",
      marginBottom: "var(--8)"
    } }, panel.history.length > 1 ? /* @__PURE__ */ m("div", { style: { rightPadding: "var(--padding)" } }, /* @__PURE__ */ m("svg", { onclick: goBack, xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", fill: "currentColor", viewBox: "0 0 16 16" }, /* @__PURE__ */ m("path", { "fill-rule": "evenodd", d: "M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z" }))) : null, /* @__PURE__ */ m("div", { style: { flexGrow: "1" } }, node.getParent() && node.getParent().ID !== "@root" ? /* @__PURE__ */ m("span", { style: { cursor: "pointer" }, onclick: () => workbench.open(node.getParent()) }, node.getParent().getName()) : /* @__PURE__ */ m("span", null, "/")), workbench.panels.flat().length > 1 ? /* @__PURE__ */ m("div", { style: { display: "flex", gap: "var(--4)", zIndex: "0", color: "var(--gray-500)", alignItems: "center" } }, /* @__PURE__ */ m("svg", { onclick: maximize, style: { cursor: "pointer" }, xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather feather-maximize-2" }, /* @__PURE__ */ m("polyline", { points: "15 3 21 3 21 9" }), /* @__PURE__ */ m("polyline", { points: "9 21 3 21 3 15" }), /* @__PURE__ */ m("line", { x1: "21", y1: "3", x2: "14", y2: "10" }), /* @__PURE__ */ m("line", { x1: "3", y1: "21", x2: "10", y2: "14" })), /* @__PURE__ */ m("svg", { onclick: close, style: { cursor: "pointer" }, xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather feather-x" }, /* @__PURE__ */ m("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), /* @__PURE__ */ m("line", { x1: "6", y1: "6", x2: "18", y2: "18" }))) : null), /* @__PURE__ */ m("div", { class: "body flex flex-col" }, /* @__PURE__ */ m("div", { oncontextmenu: (e) => workbench.showMenu(e, { node, panel }), "data-menu": "node", style: {
      fontSize: "var(--6)",
      color: "var(--gray-900)",
      fontWeight: "700"
    } }, /* @__PURE__ */ m(NodeEditor, { workbench, panel, node, disallowEmpty: true })), node.hasComponent(Page) ? /* @__PURE__ */ m(
      "textarea",
      {
        oninput: editMarkdown,
        value: node.getComponent(Page).markdown,
        placeholder: "Enter Markdown text here",
        style: {
          marginLeft: "var(--padding)",
          padding: "var(--padding)",
          outline: "0",
          height: `${calcHeight(node.getComponent(Page).markdown)}px`,
          border: "0"
        }
      },
      node.getComponent(Page).markdown
    ) : null, /* @__PURE__ */ m(OutlineEditor, { workbench, panel, node })));
  }
};

// lib/ui/quickadd.tsx
var QuickAdd = {
  view({ attrs: { workbench } }) {
    const panel = {
      id: "quickadd",
      headNode: workbench.quickadd
    };
    return /* @__PURE__ */ m("div", { style: {
      position: "absolute",
      left: "0",
      right: "0",
      top: "0",
      bottom: "0"
    } }, /* @__PURE__ */ m("div", { onclick: () => workbench.closeQuickAdd(), style: {
      position: "absolute",
      background: "black",
      opacity: "50%",
      width: "100%",
      height: "100%"
    } }), /* @__PURE__ */ m("div", { style: {
      position: "relative",
      marginLeft: "auto",
      marginRight: "auto",
      width: "45vw",
      borderRadius: "0.5rem",
      filter: "drop-shadow(2px 2px 4px #5555)",
      marginTop: "20vh",
      padding: "2rem",
      background: "white"
    } }, /* @__PURE__ */ m("h3", { style: { margin: "0" } }, "Quick Add"), /* @__PURE__ */ m("hr", null), /* @__PURE__ */ m(OutlineEditor, { workbench, node: workbench.quickadd, panel }), /* @__PURE__ */ m("hr", null), /* @__PURE__ */ m("div", { style: { textAlign: "right" } }, /* @__PURE__ */ m("button", { style: { padding: "0.5rem", margin: "0.25rem" }, onclick: () => {
      workbench.commitQuickAdd();
      workbench.closeQuickAdd();
    } }, "Add to Today"))));
  }
};

// lib/ui/search.tsx
var Search = {
  onupdate({ state, dom }) {
    const results = dom.querySelector(".results");
    if (results && state.selected !== void 0 && results.children.length > 0) {
      results.children[state.selected].scrollIntoView({ block: "nearest" });
    }
  },
  view({ attrs: { workbench }, state }) {
    state.query = state.query === void 0 ? "" : state.query;
    state.results = state.results === void 0 ? [] : state.results;
    const clear = () => {
      state.query = "";
      state.results = [];
      workbench.curtain = null;
    };
    const open = (node) => {
      workbench.open(node);
      clear();
    };
    const onkeydown = (e) => {
      const mod = (a, b) => (a % b + b) % b;
      if (e.key === "ArrowDown") {
        if (state.selected === void 0) {
          state.selected = 0;
          return;
        }
        state.selected = mod(state.selected + 1, state.results.length);
        return false;
      }
      if (e.key === "ArrowUp") {
        if (state.selected === void 0) {
          state.selected = 0;
        }
        state.selected = mod(state.selected - 1, state.results.length);
        return false;
      }
      if (e.key === "Enter") {
        if (state.selected !== void 0) {
          open(state.results[state.selected]);
        }
        return false;
      }
      if (e.key === "Escape") {
        clear();
      }
    };
    const autocomplete = (e) => {
      state.query = e.target.value;
      state.selected = 0;
      if (state.query) {
        state.results = workbench.backend.index.search(state.query).map((id) => {
          let node = workbench.workspace.find(id);
          if (!node) {
            return void 0;
          }
          if (node.getValue()) {
            node = node.getParent();
            if (!node.raw)
              return;
          }
          return node;
        }).filter((n) => n !== void 0);
      } else {
        state.results = [];
      }
      if (state.query && state.results.length > 0) {
        workbench.curtain = {
          visible: false,
          onclick: () => clear()
        };
      } else {
        workbench.curtain = null;
      }
    };
    return /* @__PURE__ */ m("div", { class: "search", style: { position: "relative", display: "flex", flexGrow: "1", marginLeft: "var(--padding)", marginRight: "var(--padding)" } }, /* @__PURE__ */ m("div", { style: {
      width: "95%",
      padding: "calc(var(--padding)/2)",
      margin: "calc(var(--padding)/-2)",
      borderRadius: "0.25rem",
      border: state.results.length > 0 ? "1px solid var(--dark)" : "none",
      position: "absolute",
      zIndex: state.results.length > 0 ? "100" : "1",
      background: state.results.length > 0 ? "white" : null
    } }, /* @__PURE__ */ m("div", { class: "flex", style: { margin: state.results.length > 0 ? "0" : "1px" } }, /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather feather-search" }, /* @__PURE__ */ m("circle", { cx: "11", cy: "11", r: "8" }), /* @__PURE__ */ m("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" })), /* @__PURE__ */ m("input", { type: "text", placeholder: "Search", value: state.query, onkeydown, oninput: autocomplete, style: {
      width: "99%",
      border: "0",
      outline: "0",
      background: "transparent",
      marginLeft: "var(--1)",
      marginRight: "var(--padding)"
    } })), state.results.length > 0 ? /* @__PURE__ */ m("div", { class: "results", style: {
      marginLeft: "20px",
      paddingLeft: "var(--1)",
      marginTop: "0.25rem",
      overflowX: "hidden",
      fontWeight: "400",
      overflowY: "auto",
      maxHeight: "400px"
    } }, state.results.map((result, idx) => /* @__PURE__ */ m("div", { onclick: () => open(result), class: state.selected === idx ? "selected" : "" }, result.getName()))) : null));
  }
};

// lib/ui/notices.tsx
var LockStolenMessage = {
  view({ attrs: { workbench, finished } }) {
    return /* @__PURE__ */ m("div", null, /* @__PURE__ */ m("h3", { style: { margin: "0" } }, "Refresh to view latest updates"), /* @__PURE__ */ m("hr", null), /* @__PURE__ */ m("p", null, "Your notes were updated in another browser session. Refresh the page to view the latest version."), /* @__PURE__ */ m("hr", null), /* @__PURE__ */ m("div", { style: { textAlign: "right" } }, /* @__PURE__ */ m("button", { style: { padding: "0.5rem", margin: "0.25rem", fontSize: "1.25rem" }, onclick: () => {
      finished();
    } }, "Refresh Now")));
  }
};
var FirstTimeMessage = {
  view({ attrs: { workbench } }) {
    return /* @__PURE__ */ m("div", null, /* @__PURE__ */ m("h3", { style: { margin: "0" } }, "Treehouse is under active development"), /* @__PURE__ */ m("hr", null), /* @__PURE__ */ m("p", null, "This is a preview based on our main branch, which is actively being developed."), /* @__PURE__ */ m("p", null, "If you find a bug, please report it via [ ", /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", style: { display: "inline", marginLeft: "0.25rem", marginRight: "0.25rem" }, width: "16", height: "16", fill: "currentColor", viewBox: "0 0 16 16" }, /* @__PURE__ */ m("path", { d: "M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z" })), " > Submit Issue ]."), /* @__PURE__ */ m("p", null, "Data is stored using localstorage, which you can reset via [ ", /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", style: { display: "inline", marginLeft: "0.25rem", marginRight: "0.25rem" }, width: "16", height: "16", fill: "currentColor", viewBox: "0 0 16 16" }, /* @__PURE__ */ m("path", { d: "M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z" })), " > Reset Demo ]."), /* @__PURE__ */ m("hr", null), /* @__PURE__ */ m("div", { style: { textAlign: "right" } }, /* @__PURE__ */ m("button", { style: { padding: "0.5rem", margin: "0.25rem", fontSize: "1.25rem" }, onclick: () => {
      localStorage.setItem("firsttime", "1");
      workbench.hideNotice();
    } }, "Got it")));
  }
};
var GitHubMessage = {
  view({ attrs: { workbench, finished } }) {
    return /* @__PURE__ */ m("div", null, /* @__PURE__ */ m("h3", { style: { margin: "0" } }, "Login with GitHub"), /* @__PURE__ */ m("hr", null), /* @__PURE__ */ m("p", null, "The GitHub backend is experimental so use at your own risk!"), /* @__PURE__ */ m("p", null, "To store your workbench we will create a public repository called ", /* @__PURE__ */ m("pre", { style: { display: "inline" } }, "<username>.treehouse.sh"), " if it doesn't already exist. You can manually make this repository private via GitHub if you want."), /* @__PURE__ */ m("p", null, "You can Logout via the", /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", style: { display: "inline", marginLeft: "0.5rem", marginRight: "0.5rem" }, width: "16", height: "16", fill: "currentColor", viewBox: "0 0 16 16" }, /* @__PURE__ */ m("path", { d: "M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311c.446.82.023 1.841-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z" })), "menu in the top right to return to the localstorage backend."), /* @__PURE__ */ m("hr", null), /* @__PURE__ */ m("div", { style: { textAlign: "right" } }, /* @__PURE__ */ m("button", { style: { padding: "0.5rem", margin: "0.25rem", fontSize: "1.25rem" }, onclick: () => {
      workbench.hideNotice();
      localStorage.setItem("github", "1");
      finished();
    } }, "Login with GitHub"), /* @__PURE__ */ m("button", { style: { padding: "0.5rem", margin: "0.25rem", fontSize: "1.25rem" }, onclick: () => {
      workbench.hideNotice();
    } }, "Cancel")));
  }
};
var Notice = {
  view({ attrs: { workbench, message, finished } }) {
    return /* @__PURE__ */ m("div", { style: {
      position: "absolute",
      left: "0",
      right: "0",
      top: "0",
      bottom: "0"
    } }, /* @__PURE__ */ m("div", { style: {
      position: "absolute",
      background: "black",
      opacity: "50%",
      width: "100%",
      height: "100%"
    } }), /* @__PURE__ */ m("div", { style: {
      position: "relative",
      marginLeft: "auto",
      marginRight: "auto",
      fontSize: "1.25rem",
      width: "680px",
      borderRadius: "0.5rem",
      filter: "drop-shadow(2px 2px 4px #5555)",
      marginTop: "20vh",
      padding: "2rem",
      background: "white"
    } }, m({
      "firsttime": FirstTimeMessage,
      "github": GitHubMessage,
      "lockstolen": LockStolenMessage
    }[message], { workbench, finished })));
  }
};

// lib/ui/app.tsx
var App = {
  view({ attrs: { workbench }, state }) {
    state.open = state.open === void 0 ? true : state.open;
    const toggle = (e) => {
      if (state.open) {
        state.open = false;
      } else {
        state.open = true;
      }
    };
    return /* @__PURE__ */ m("main", { class: "workbench m-0 flex flex-row absolute inset-0", style: { overflow: "none" } }, /* @__PURE__ */ m("div", { class: "sidebar flex flex-col", style: { width: state.open ? "256px" : "52px", borderRight: "1px solid var(--gray-200)", backgroundColor: "var(--gray-100)" } }, /* @__PURE__ */ m("div", { style: { padding: "var(--padding)", borderBottom: "1px solid var(--gray-200)", height: "56px" } }, /* @__PURE__ */ m("img", { src: "/icon_transparent.png", style: { opacity: "40%", width: "20px", height: "20px" } })), /* @__PURE__ */ m("div", { class: "grow", style: { padding: "var(--padding)", color: "var(--gray-900)", fontWeight: "500" } }, state.open && workbench.workspace.module.getRoot().getChildren().map((node) => /* @__PURE__ */ m(NavNode, { node, expanded: true, level: 0, workbench }))), /* @__PURE__ */ m("div", { style: { padding: "var(--padding)", color: "var(--gray-500)" } }, /* @__PURE__ */ m("svg", { onclick: toggle, xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather feather-sidebar" }, /* @__PURE__ */ m("rect", { x: "3", y: "3", width: "18", height: "18", rx: "2", ry: "2" }), /* @__PURE__ */ m("line", { x1: "9", y1: "3", x2: "9", y2: "21" })))), /* @__PURE__ */ m("div", { class: "main flex flex-col", style: { flexGrow: "1" } }, /* @__PURE__ */ m("div", { class: "topbar flex", style: {
      padding: "var(--padding)",
      paddingLeft: "calc(var(--padding)*2)",
      paddingRight: "calc(var(--padding)*2)",
      lineHeight: "1",
      fontSize: "0.875rem",
      color: "var(--gray-900)",
      fontWeight: "600",
      borderBottom: "1px solid var(--gray-200)",
      height: "56px"
    } }, /* @__PURE__ */ m("div", { onclick: () => workbench.openToday(), style: { cursor: "pointer", marginLeft: "var(--padding)", marginRight: "var(--padding)", display: "flex", alignItems: "center" } }, /* @__PURE__ */ m("svg", { style: { marginRight: "var(--1)" }, xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather feather-calendar" }, /* @__PURE__ */ m("rect", { x: "3", y: "4", width: "18", height: "18", rx: "2", ry: "2" }), /* @__PURE__ */ m("line", { x1: "16", y1: "2", x2: "16", y2: "6" }), /* @__PURE__ */ m("line", { x1: "8", y1: "2", x2: "8", y2: "6" }), /* @__PURE__ */ m("line", { x1: "3", y1: "10", x2: "21", y2: "10" })), /* @__PURE__ */ m("div", null, "Today")), /* @__PURE__ */ m("div", { onclick: () => workbench.openQuickAdd(), style: { cursor: "pointer", marginLeft: "var(--padding)", marginRight: "var(--padding)", display: "flex", alignItems: "center" } }, /* @__PURE__ */ m("svg", { style: { marginRight: "var(--1)" }, xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather feather-plus-circle" }, /* @__PURE__ */ m("circle", { cx: "12", cy: "12", r: "10" }), /* @__PURE__ */ m("line", { x1: "12", y1: "8", x2: "12", y2: "16" }), /* @__PURE__ */ m("line", { x1: "8", y1: "12", x2: "16", y2: "12" })), /* @__PURE__ */ m("div", null, "Quick Add")), /* @__PURE__ */ m(Search, { workbench }), /* @__PURE__ */ m("div", { onclick: (e) => workbench.showMenu(e), "data-menu": "settings", "data-align": "right", style: { cursor: "pointer", marginLeft: "var(--padding)", marginRight: "var(--padding)" } }, /* @__PURE__ */ m("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round", class: "feather feather-menu" }, /* @__PURE__ */ m("line", { x1: "3", y1: "12", x2: "21", y2: "12" }), /* @__PURE__ */ m("line", { x1: "3", y1: "6", x2: "21", y2: "6" }), /* @__PURE__ */ m("line", { x1: "3", y1: "18", x2: "21", y2: "18" })))), /* @__PURE__ */ m("div", { class: "panels flex flex-row", style: { position: "relative", overflow: "hidden" } }, workbench.panels.map((row) => row.map((panel) => /* @__PURE__ */ m("div", { style: {
      borderRight: "1px solid var(--gray-200)",
      flex: "1 1 auto",
      overflowY: "auto"
    } }, /* @__PURE__ */ m(Panel2, { workbench, panel })))))), workbench.curtain && /* @__PURE__ */ m("div", { onclick: workbench.curtain.onclick, style: {
      zIndex: "10",
      position: "absolute",
      background: "black",
      opacity: workbench.curtain.visible ? "50%" : "0%",
      width: "100%",
      height: "100%"
    } }), workbench.menu && /* @__PURE__ */ m(Menu, { workbench, ...workbench.menu }), workbench.palette && /* @__PURE__ */ m(CommandPalette, { workbench, ...workbench.palette }), workbench.quickadd && /* @__PURE__ */ m(QuickAdd, { workbench }), workbench.notice && /* @__PURE__ */ m(Notice, { workbench, ...workbench.notice }));
  }
};
var NavNode = {
  view({ attrs: { node, workbench, expanded, level }, state }) {
    state.expanded = state.expanded === void 0 ? expanded : state.expanded;
    const expandable = node.childCount() > 0 && level < 3;
    const toggle = (e) => {
      if (!expandable)
        return;
      if (state.expanded) {
        state.expanded = false;
      } else {
        state.expanded = true;
      }
      e.stopPropagation();
    };
    const open = (e) => {
      workbench.open(node);
    };
    return /* @__PURE__ */ m("div", null, /* @__PURE__ */ m("div", { style: { display: "flex", paddingBottom: "var(--1)", paddingTop: "var(--1)" } }, /* @__PURE__ */ m("svg", { onclick: toggle, style: { cursor: "pointer", flexShrink: "0", paddingTop: "0px", marginRight: "0.125rem" }, class: "feather feather-chevron-right", width: "16", height: "16", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round", xmlns: "http://www.w3.org/2000/svg" }, expandable ? state.expanded ? /* @__PURE__ */ m("polyline", { points: "6 9 12 15 18 9" }) : /* @__PURE__ */ m("polyline", { points: "9 18 15 12 9 6" }) : null), /* @__PURE__ */ m("div", { onclick: open, style: { cursor: "pointer", lineHeight: "1.25", fontSize: "0.875rem", flexGrow: "1", maxWidth: "100%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" } }, node.getName())), state.expanded && /* @__PURE__ */ m("div", { style: { marginLeft: "0.5rem" } }, node.getChildren().filter((n) => n.getName() !== "").map((n) => /* @__PURE__ */ m(NavNode, { workbench, node: n, level: level + 1 }))));
  }
};

// lib/backend/browser.ts
var BrowserBackend = class {
  constructor() {
    this.auth = null;
    this.files = new FileStore();
    if (window.MiniSearch) {
      this.index = new SearchIndex_MiniSearch();
    } else {
      this.index = new SearchIndex_Dumb();
    }
  }
};
var SearchIndex_MiniSearch = class {
  // MiniSearch
  constructor() {
    this.indexer = new MiniSearch({
      idField: "ID",
      fields: ["ID", "Name", "Value.markdown"],
      // fields to index for full-text search
      storeFields: ["ID"],
      // fields to return with search results
      extractField: (document2, fieldName) => {
        return fieldName.split(".").reduce((doc, key) => doc && doc[key], document2);
      }
    });
  }
  index(node) {
    if (this.indexer.has(node.ID)) {
      this.indexer.replace(node);
    } else {
      this.indexer.add(node);
    }
  }
  remove(id) {
    this.indexer.discard(id);
  }
  search(query) {
    const suggested = this.indexer.autoSuggest(query);
    if (suggested.length === 0)
      return [];
    return this.indexer.search(suggested[0].suggestion).map((doc) => doc.ID);
  }
};
var SearchIndex_Dumb = class {
  constructor() {
    this.nodes = {};
  }
  index(node) {
    this.nodes[node.ID] = node.Name;
  }
  remove(id) {
    delete this.nodes[id];
  }
  search(query) {
    const results = [];
    for (const id in this.nodes) {
      if (this.nodes[id].includes(query)) {
        results.push(id);
      }
    }
    return results;
  }
};
var FileStore = class {
  async readFile(path) {
    return localStorage.getItem(`treehouse:${path}`);
  }
  async writeFile(path, contents) {
    localStorage.setItem(`treehouse:${path}`, contents);
  }
};

// lib/backend/github.ts
import { encode, decode } from "https://cdn.jsdelivr.net/npm/js-base64@3.7.5/base64.mjs";
var GitHubBackend = class {
  // path => sha
  constructor(loginURL, octokit) {
    this.loginURL = loginURL;
    this.clientFactory = octokit;
    this.auth = this;
    this.shas = {};
    const localbackend = new BrowserBackend();
    this.index = localbackend.index;
    this.files = localbackend.files;
  }
  get repo() {
    return `${this.user?.userID()}.treehouse.sh`;
  }
  async initialize() {
    const code = new URL(location.href).searchParams.get("code");
    if (code) {
      try {
        const querystring = location.search.replace(/\bcode=\w+/, "").replace(/\?$/, "");
        history.pushState({}, "", `${location.pathname}${querystring}`);
        const response = await fetch(this.loginURL, {
          method: "POST",
          mode: "cors",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ code })
        });
        const result = await response.json();
        if (result.error) {
          throw result.error;
        }
        localStorage.setItem("treehouse:gh-token", result.token);
      } catch (e) {
        this.reset();
        console.error(e);
        return;
      }
    }
    await this.authenticate();
    if (!this.user) {
      console.error("authentication failed");
      return;
    }
    try {
      await this.client.rest.repos.get({
        owner: this.user.userID(),
        repo: this.repo
      });
    } catch (e) {
      if (e.message !== "Not Found") {
        throw e;
      }
      console.log("Creating repository...");
      const resp = await this.client.rest.repos.createForAuthenticatedUser({ name: this.repo });
      if (resp.status !== 201) {
        console.error(resp);
        return;
      }
    }
    try {
      await this.client.rest.repos.getContent({
        owner: this.user.userID(),
        repo: this.repo,
        path: "workspace.json"
      });
    } catch (e) {
      if (e.name !== "HttpError") {
        throw e;
      }
      console.log("Creating workspace.json...");
      const resp = await this.client.rest.repos.createOrUpdateFileContents({
        owner: this.user.userID(),
        repo: this.repo,
        path: "workspace.json",
        message: "initial commit",
        content: btoa(JSON.stringify([]))
      });
      if (resp.status !== 201) {
        console.error(resp);
        return;
      }
    }
    this.files = this;
    const sessID = uniqueID();
    await this.readFile("treehouse.lock");
    await this.writeFile("treehouse.lock", sessID);
    const lockCheck = setInterval(async () => {
      const lockFile = await this.readFile("treehouse.lock");
      if (lockFile !== sessID) {
        clearInterval(lockCheck);
        document.dispatchEvent(new CustomEvent("BackendError"));
        console.warn("lock stolen!");
      }
    }, 5e3);
  }
  async authenticate() {
    const token = localStorage.getItem("treehouse:gh-token");
    if (!token) {
      return;
    }
    this.client = new this.clientFactory({ auth: token });
    const resp = await this.client.rest.users.getAuthenticated();
    if (!resp || resp.error) {
      return;
    }
    this.user = new User(resp.data);
    if (m)
      m.redraw();
  }
  currentUser() {
    return this.user;
  }
  login() {
    location.assign(this.loginURL);
  }
  reset() {
    localStorage.removeItem("treehouse:gh-token");
    this.user = null;
    if (m)
      m.redraw();
  }
  logout() {
    this.reset();
    location.reload();
  }
  async readFile(path) {
    try {
      const resp = await this.client.rest.repos.getContent({
        owner: this.user?.userID(),
        repo: this.repo,
        path,
        random: Math.random().toString(36).substring(2)
      });
      this.shas[path] = resp.data.sha;
      return decode(resp.data.content);
    } catch (e) {
      if (e.name !== "HttpError") {
        console.error(e);
      }
      return null;
    }
  }
  async writeFile(path, contents) {
    const resp = await this.client.rest.repos.createOrUpdateFileContents({
      owner: this.user?.userID(),
      repo: this.repo,
      path,
      message: "autosave",
      content: encode(contents),
      sha: this.shas[path]
    });
    this.shas[path] = resp.data.content.sha;
  }
};
var User = class {
  // github user object
  constructor(user) {
    this.user = user;
  }
  userID() {
    return this.user.login;
  }
  displayName() {
    return this.user.name;
  }
  avatarURL() {
    return this.user.avatar_url;
  }
};
function uniqueID() {
  const dateString = Date.now().toString(36);
  const randomness = Math.random().toString(36).substring(2);
  return dateString + randomness;
}

// lib/mod.ts
var Checkbox = class {
  constructor() {
    this.checked = false;
  }
};
Checkbox = __decorateClass([
  component
], Checkbox);
var Page = class {
  constructor() {
    this.markdown = "";
  }
};
Page = __decorateClass([
  component
], Page);
async function setup(document2, target, backend) {
  if (backend.initialize) {
    await backend.initialize();
  }
  const workbench = new Workbench(backend);
  window.workbench = workbench;
  await workbench.initialize();
  document2.addEventListener("BackendError", () => {
    workbench.showNotice("lockstolen", () => {
      location.reload();
    });
  });
  workbench.commands.registerCommand({
    id: "add-page",
    title: "Add page",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const page = new Page();
      ctx.node.addComponent(page);
    }
  });
  workbench.commands.registerCommand({
    id: "remove-page",
    title: "Remove page",
    action: (ctx) => {
      if (!ctx.node)
        return;
      ctx.node.removeComponent(Page);
    }
  });
  workbench.commands.registerCommand({
    id: "add-checkbox",
    title: "Add checkbox",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const checkbox = new Checkbox();
      ctx.node.addComponent(checkbox);
    }
  });
  workbench.commands.registerCommand({
    id: "remove-checkbox",
    title: "Remove checkbox",
    action: (ctx) => {
      if (!ctx.node)
        return;
      ctx.node.removeComponent(Checkbox);
    }
  });
  workbench.commands.registerCommand({
    id: "mark-done",
    title: "Mark done",
    action: (ctx) => {
      if (!ctx.node)
        return;
      if (ctx.node.hasComponent(Checkbox)) {
        const checkbox = ctx.node.getComponent(Checkbox);
        if (!checkbox.checked) {
          checkbox.checked = true;
          ctx.node.changed();
        } else {
          ctx.node.removeComponent(Checkbox);
        }
      } else {
        const checkbox = new Checkbox();
        ctx.node.addComponent(checkbox);
      }
    }
  });
  workbench.keybindings.registerBinding({ command: "mark-done", key: "meta+enter" });
  workbench.commands.registerCommand({
    id: "expand",
    title: "Expand",
    action: (ctx) => {
      if (!ctx.node)
        return;
      workbench.workspace.setExpanded(ctx.panel.headNode, ctx.node, true);
      m.redraw();
    }
  });
  workbench.keybindings.registerBinding({ command: "expand", key: "meta+arrowdown" });
  workbench.commands.registerCommand({
    id: "collapse",
    title: "Collapse",
    action: (ctx) => {
      if (!ctx.node)
        return;
      workbench.workspace.setExpanded(ctx.panel.headNode, ctx.node, false);
      m.redraw();
    }
  });
  workbench.keybindings.registerBinding({ command: "collapse", key: "meta+arrowup" });
  workbench.commands.registerCommand({
    id: "indent",
    title: "Indent",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const prev = ctx.node.getPrevSibling();
      if (prev !== null) {
        ctx.node.setParent(prev);
        workbench.workspace.setExpanded(ctx.panel.headNode, prev, true);
        const node = ctx.node;
        m.redraw.sync();
        workbench.focus(node);
      }
    }
  });
  workbench.keybindings.registerBinding({ command: "indent", key: "tab" });
  workbench.commands.registerCommand({
    id: "outdent",
    title: "Outdent",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const parent = ctx.node.getParent();
      if (parent !== null && parent.ID !== "@root") {
        ctx.node.setParent(parent.getParent());
        ctx.node.setSiblingIndex(parent.getSiblingIndex() + 1);
        if (parent.childCount() === 0) {
          workbench.workspace.setExpanded(ctx.panel.headNode, parent, false);
        }
        const node = ctx.node;
        m.redraw.sync();
        workbench.focus(node);
      }
    }
  });
  workbench.keybindings.registerBinding({ command: "outdent", key: "shift+tab" });
  workbench.commands.registerCommand({
    id: "move-up",
    title: "Move Up",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const node = ctx.node;
      const parent = node.getParent();
      if (parent !== null && parent.ID !== "@root") {
        const children = parent.childCount();
        if (node.getSiblingIndex() === 0) {
          if (!parent.getPrevSibling()) {
            return;
          }
          const parentSib = parent.getPrevSibling();
          node.setParent(parentSib);
          node.setSiblingIndex(parentSib.childCount() - 1);
          workbench.workspace.setExpanded(ctx.panel.headNode, parentSib, true);
          m.redraw.sync();
          workbench.focus(node);
        } else {
          if (children === 1) {
            return;
          }
          node.setSiblingIndex(node.getSiblingIndex() - 1);
          m.redraw.sync();
        }
      }
    }
  });
  workbench.keybindings.registerBinding({ command: "move-up", key: "shift+meta+arrowup" });
  workbench.commands.registerCommand({
    id: "move-down",
    title: "Move Down",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const node = ctx.node;
      const parent = node.getParent();
      if (parent !== null && parent.ID !== "@root") {
        const children = parent.childCount();
        if (node.getSiblingIndex() === children - 1) {
          if (!parent.getNextSibling()) {
            return;
          }
          const parentSib = parent.getNextSibling();
          node.setParent(parentSib);
          node.setSiblingIndex(0);
          workbench.workspace.setExpanded(ctx.panel.headNode, parentSib, true);
          m.redraw.sync();
          workbench.focus(node);
        } else {
          if (children === 1) {
            return;
          }
          node.setSiblingIndex(node.getSiblingIndex() + 1);
          m.redraw.sync();
        }
      }
    }
  });
  workbench.keybindings.registerBinding({ command: "move-down", key: "shift+meta+arrowdown" });
  workbench.commands.registerCommand({
    id: "insert-child",
    title: "Insert Child",
    action: (ctx, name = "", siblingIndex) => {
      if (!ctx.node)
        return;
      const node = workbench.workspace.new(name);
      node.setParent(ctx.node);
      if (siblingIndex !== void 0) {
        node.setSiblingIndex(siblingIndex);
      }
      workbench.workspace.setExpanded(ctx.panel.headNode, ctx.node, true);
      m.redraw.sync();
      workbench.focus(node, ctx.panel, name.length);
    }
  });
  workbench.commands.registerCommand({
    id: "insert-before",
    title: "Insert Before",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const node = workbench.workspace.new("");
      node.setParent(ctx.node.getParent());
      node.setSiblingIndex(ctx.node.getSiblingIndex());
      m.redraw.sync();
      workbench.focus(node, ctx.panel);
    }
  });
  workbench.commands.registerCommand({
    id: "insert",
    title: "Insert Node",
    action: (ctx, name = "") => {
      if (!ctx.node)
        return;
      const node = workbench.workspace.new(name);
      node.setParent(ctx.node.getParent());
      node.setSiblingIndex(ctx.node.getSiblingIndex() + 1);
      m.redraw.sync();
      workbench.focus(node, ctx.panel);
    }
  });
  workbench.keybindings.registerBinding({ command: "insert", key: "shift+enter" });
  workbench.commands.registerCommand({
    id: "delete",
    title: "Delete node",
    action: (ctx) => {
      if (!ctx.node)
        return;
      if (ctx.node.ID.startsWith("@"))
        return;
      const above = workbench.workspace.findAbove(ctx.panel.headNode, ctx.node);
      ctx.node.destroy();
      m.redraw.sync();
      if (above) {
        let pos = 0;
        if (ctx.event && ctx.event.key === "Backspace") {
          pos = above.getName().length;
        }
        if (above.childCount() === 0) {
          workbench.workspace.setExpanded(ctx.panel.headNode, above, false);
        }
        workbench.focus(above, ctx.panel, pos);
      }
    }
  });
  workbench.keybindings.registerBinding({ command: "delete", key: "shift+meta+backspace" });
  workbench.commands.registerCommand({
    id: "prev",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const above = workbench.workspace.findAbove(ctx.panel.headNode, ctx.node);
      if (above) {
        workbench.focus(above, ctx.panel);
      }
    }
  });
  workbench.keybindings.registerBinding({ command: "prev", key: "arrowup" });
  workbench.commands.registerCommand({
    id: "next",
    action: (ctx) => {
      if (!ctx.node)
        return;
      const below = workbench.workspace.findBelow(ctx.panel.headNode, ctx.node);
      if (below) {
        workbench.focus(below, ctx.panel);
      }
    }
  });
  workbench.keybindings.registerBinding({ command: "next", key: "arrowdown" });
  workbench.commands.registerCommand({
    id: "pick-command",
    action: (ctx) => {
      let node = ctx.node;
      let posBelow = false;
      if (!node) {
        node = ctx.panel.headNode;
        posBelow = true;
      }
      const trigger = workbench.getInput(node);
      const rect = trigger.getBoundingClientRect();
      let x = document2.body.scrollLeft + rect.x + trigger.selectionStart * 10 + 20;
      let y = document2.body.scrollTop + rect.y - 8;
      if (posBelow) {
        x = document2.body.scrollLeft + rect.x;
        y = document2.body.scrollTop + rect.y + rect.height;
      }
      workbench.showPalette(x, y, workbench.newContext({ node }));
    }
  });
  workbench.keybindings.registerBinding({ command: "pick-command", key: "meta+k" });
  workbench.commands.registerCommand({
    id: "new-panel",
    title: "Open in New Panel",
    action: (ctx) => {
      if (!ctx.node)
        return;
      workbench.openNewPanel(ctx.node);
      m.redraw();
    }
  });
  workbench.commands.registerCommand({
    id: "close-panel",
    title: "Close Panel",
    action: (ctx, panel) => {
      workbench.closePanel(panel || ctx.node.panel);
      workbench.context.panel = workbench.mainPanel;
      m.redraw();
    }
  });
  workbench.commands.registerCommand({
    id: "open",
    title: "Open",
    action: (ctx) => {
      ctx.panel.open(ctx.node);
      workbench.workspace.lastOpenedID = ctx.node.ID;
      workbench.workspace.save();
      m.redraw();
    }
  });
  workbench.commands.registerCommand({
    id: "generate-random",
    title: "Generate Random Children",
    action: (ctx) => {
      if (!ctx.node)
        return;
      [...Array(100)].forEach(() => {
        const node = workbench.workspace.new(generateName(8));
        node.setParent(ctx.node);
      });
    }
  });
  workbench.menus.registerMenu("node", [
    { command: "open" },
    { command: "new-panel" },
    { command: "indent" },
    { command: "outdent" },
    { command: "move-up" },
    { command: "move-down" },
    { command: "delete" },
    // {command: "add-checkbox"}, 
    // {command: "remove-checkbox"},
    { command: "mark-done" },
    { command: "add-page" },
    // {command: "remove-page"},
    { command: "generate-random" }
  ]);
  workbench.menus.registerMenu("settings", [
    { title: () => `${workbench.backend.auth?.currentUser()?.userID()} @ GitHub`, disabled: true, when: () => workbench.authenticated() },
    { title: () => "Login with GitHub", when: () => !workbench.authenticated(), onclick: () => {
      if (!localStorage.getItem("github")) {
        workbench.showNotice("github", () => {
          workbench.backend.auth.login();
        });
      } else {
        workbench.backend.auth.login();
      }
    } },
    { title: () => "Reset Demo", when: () => !workbench.authenticated(), onclick: () => {
      localStorage.clear();
      location.reload();
    } },
    { title: () => "Submit Issue", onclick: () => window.open("https://github.com/treehousedev/treehouse/issues", "_blank") },
    { title: () => "Logout", when: () => workbench.authenticated(), onclick: () => workbench.backend.auth.logout() }
  ]);
  document2.addEventListener("keydown", (e) => {
    const binding = workbench.keybindings.evaluateEvent(e);
    if (binding) {
      workbench.commands.executeCommand(binding.command, workbench.context);
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    if (e.key === "Escape") {
      if (workbench.curtain && workbench.curtain.onclick) {
        workbench.curtain.onclick(e);
      }
    }
  });
  m.mount(target, { view: () => m(App, { workbench }) });
}
function generateName(length = 10) {
  const random = (min, max) => {
    return Math.round(Math.random() * (max - min) + min);
  };
  const word = () => {
    const words2 = [
      "got",
      "ability",
      "shop",
      "recall",
      "fruit",
      "easy",
      "dirty",
      "giant",
      "shaking",
      "ground",
      "weather",
      "lesson",
      "almost",
      "square",
      "forward",
      "bend",
      "cold",
      "broken",
      "distant",
      "adjective"
    ];
    return words2[random(0, words2.length - 1)];
  };
  const words = (length2) => [...Array(length2)].map((_, i) => word()).join(" ").trim();
  return words(random(2, length));
}
export {
  BrowserBackend,
  Checkbox,
  GitHubBackend,
  Page,
  SearchIndex_MiniSearch,
  setup
};
